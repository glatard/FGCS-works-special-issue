\documentclass[preprint,3p,twocolumn]{elsarticle}

\usepackage[x11names,dvipsnames,table]{xcolor} %for use in color links
\usepackage{svg}
\usepackage{url}
\usepackage{xspace}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{multirow}

\newcommand{\todo}[1]{\color{blue}\xspace\emph{#1}\xspace\color{black}}
\newcommand{\note}[1]{\color{blue}\textbf{Note: }\textit{#1} \color{black}}

\begin{document}

\begin{frontmatter}

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for theassociated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for theassociated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for theassociated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \address{Address\fnref{label3}}
%% \fntext[label3]{}

\title{Architectures for workflow integration in science gateways}

%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{}
%% \address[label1]{}
%% \address[label2]{}

\author{}

\address{}

\begin{abstract}
%% Text of abstract

\end{abstract}

\begin{keyword}
%% keywords here, in the form: keyword \sep keyword

%% PACS codes here, in the form: \PACS code \sep code

%% MSC codes here, in the form: \MSC code \sep code
%% or \MSC[2008] code \sep code (2000 is the default)

\end{keyword}

\end{frontmatter}

%\authors{Tristan Glatard, Marc-Etienne Rousseau, Pierre Rioux, Samir
%Das, Natacha Beck, Reza Adalat, Pierre Bellec, Pierre-Olivier Quirion,
%S\'ilvia D. Olabarriaga, Sorina Camarasu-Pop, Alan C. Evans}
% Rafael? Ewa? Peter Kacsuk? Johan? Satra? Najma?

\journal{Future Generation Computer Systems}

\maketitle

\section{Introduction}

\todo{Say that the review is done based on our experience with VIP,
  CBRAIN, and to some extent SHIWA.}

\paragraph{Context} The question of integrating workflow engines in
science gateways can be seen at various levels, corresponding to
various definitions of workflows. One level is the SHIWA level, where
it was considered that workflow engines are aware of the DCI (and 'D'
is important because of data transfers, proxies, etc). Another level
is to remove 'D' from the definition: a workflow engine becomes a
program that submits jobs, potentially only to local clusters. It
opens a whole new class of workflow engines that we used to consider
as "applications". For instance, in neuroinformatics: Nipype, PSOM,
but also FSL through the fslsub tool. A workflow engine is not
supposed to be aware of the science gateway.  A wide-array of workflow
engines are available with specificies coming from the application
domain, available tools, etc Their integration in science gateways
becomes critical. Several of the examples presented in the
paper will be taken from medical image analysis, in particular
neuroimaging.

\paragraph{Goal} this paper reviews and compares the architectures to
integrate workflow engines in science gateways.

\paragraph{Contributions}
\begin{itemize}
\item We evaluate architectures based on our experience with existing systems
\item We propose a new architecture
\end{itemize}

\section{Workflow engines and science gateways}

\subsection{Workflow engines}

In the last decade, the e-Science workflow community has developed
high-level workflow systems to help developers access distributed
infrastructures such as grids and web services, resulting in tools
such as Askalon, Hyperflow, MOTEUR, Pegasus, Swift, Taverna, Triana,
VizTrails, WS-PGRADE/gUSE, etc. Such workflow engines usually describe
applications in a specific language that offers operators for parallel
computing, visual description and edition, links with domain-specific
tool repositories, etc. Descriptions and experiments conducted with
e-Science workflow engines were published in journals such as Future
Generation Computer Systems and conference venues such as
WORKS. 

At the same time, specific toolboxes were emerging in various
scientific domains to facilitate interactions between different
software components. In neuroimaging for instance, tools such as
Nipype, PSOM, SPM and FSL provide abstractions and functions to define
processes that handle the data flow between other processes. Soon,
such tools were interfaced to computing systems, in particular
clusters: they were extended to create cluster tasks, handle their
dependencies, and execute them on clusters. For instance, FSL can
launch tasks on SGE through its \texttt{fsl\_sub} tool, Nipype
\todo{...}, PSOM \todo{...}, and SPM \todo{...}. Although distributed
infrastructures are hardly handled, such domain-specific tools have to
be called workflow engines. They represent a tremendous opportunity
for science gateways to leverage existing tools and
applications. Whether these should be combined with e-Science workflow
engines is an open question.

A workflow engine is defined as a software that submits jobs to a
cluster, grid or cloud. Workflows may be expressed in any language,
including scripts. Several workflow engines may be combined in the
same science gateway. Workflow: a process that submits tasks to the
infrastructure. FSL tools, say Feat, can be considered as workflows
when they are configured to submit tasks to clusters using fslsub. A
workflow consists of activities. We are talking only about concrete
workflows with a configuration (see terstyansky et al 2014 "enabling
scientific workflow sharing...")

  Workflow engine: executes workflows, i.e. process their dependencies
  and create computing tasks. Might transfer data too. A workflow
  engine is not supposed to be aware of the science gateway.

\subsection{Science gateways}

Science Gateway: An ecosystem, usually accessible through a web
  portal, that provides tools to access distributed
  infrastructures. Tools usually help users manage data transfers,
  task execution and authentication on multiple computing and storage
  locations. Examples: CBRAIN, VIP, NSG, etc

Multi-engine, multi-language.


\subsection{Infrastructures}

\todo{Maybe this is not relevant}

The infrastructure consists of the computing and storage resources
involved in the workflow execution, and the software services used to
access these resources. Infrastructures can be servers, clusters,
grids or clouds. Some workflow engines may assume specific
characteristics about the infrastructure, such as the presence of a
shared file system between the computing nodes.

\section{Architectures}

Architectures are defined below from their main components and the
interactions between these components.

\todo{Introduce the notion of architectural diagram with an abstract figure. Mention arrows, boxes, box with dotted lines, red color.}

%http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4782949

\subsection{Interactions}

The interactions described below are labeled consistently with the
notations used on Figures~\ref{archi:tight}-\ref{archi:import}.

\begin{enumerate}[leftmargin=0cm,itemindent=0.6cm,label=\texttt{(\alph*)}]

\item Workflow integration: consists in adding a new workflow to the
  science gateway so that users can execute it. It is conducted by
  science gateway administrators, developers or users, and it results
  in an interface, for instance a web form, where users can enter the
  parameters of the workflow to be executed. Integrating a workflow is
  not the same process as integrating a workflow engine.
\item Task control: operations to manage tasks on the infrastructure,
  including: submission, monitoring, termination, deletion, etc.
\item Data control: operations to manage data on
  the infrastructure, such as: upload, download, deletion, browsing,
  replication, caching, etc. Data movements can be triggered by the
  user, to upload input data or download processed data -- interaction
  \texttt{$c_1$}, or by the workflow engine, to transfer data across the
  infrastructure -- interaction \texttt{$c_2$}. \todo{add c1 and c2 to the
    Figures}
\item Workflow control: operations to execute a workflow, including:
  submission, monitoring, termination, etc. Workflow control can be
  coarse-grained (a.k.a. black box) or fine-grained (white box). In a
  coarse-grained model, workflow activities are masked. 
\item Sub-task control: operations used by tasks to submit sub-tasks
  on the infrastructure, including: submission, monitoring,
  termination, deletion, etc.
\item Pool-agent: specific to the architecture described in~\ref{sec:pool}.
\item Workflow conversion: translation from one workflow language to
  another one.
\end{enumerate}

\subsection{Tight integration}

See Figure~\ref{archi:tight}. The workflow engine is tightly
integrated with the science gateway, which means that it is deployed
on the same machine and potentially shares code, libraries and other
software components with the science gateway. For instance, the
workflow engine might be a portlet in a Liferay portal, a controller
in a Ruby on Rails application, and so on. The workflow engine and the
science gateway usually share a database where application, users and
other resources are stored. In this model, task control and data
control are initiated from the science gateway. This is the model
adopted in the Catania Science Gateway Framework~\cite{Ardizzone2012}
(see specific documentation on
workflows\footnote{\url{http://bit.ly/1oQrzvQ}}),
CIPRES~\cite{miller2010creating} and LONI Pipeline
Environment~\cite{dinov2009efficient}.\todo{Add better justification}

\begin{figure}
\centering
\def\svgwidth{0.5\columnwidth}
\input{figures/tight.pdf_tex}
\caption{Tight integration}
\label{archi:tight}
\end{figure}

\subsection{Service invocation}

See Figure~\ref{archi:service}. The workflow engine is available
externally to the science gateway, in a service. The science gateway
controls the service through a specific interaction that might be
implemented as a web-service call (e.g. RESTful or SOAP), as a
command-line or as any other method that offers a well-defined
interface to the workflow engine. The workflow engine might be invoked
either as a black box that completely masks the infrastructure and
workflow activities, or as a grey box that allows for some interaction
with them.  The workflow engine is responsible for controlling the
tasks on the infrastructure, and performing the required data
transfers to execute them. User data is usually managed through the
science gateway, although it might as well be delivered by the
workflow engine directly to the user.

This architecture is largely adopted, in systems such as Apache
Airvata~\cite{marru2011apache}, Vine
Toolkit~\cite{DBLP:journals/scpe/SzejnfeldDKKKKLPTWDNW10}, Virtual
Imaging Platform~\cite{GLAT-13}, the WS-PGRADE/gUSE
framework~\cite{Kacsuk2012} and the numerous science gateway instances
that use it~\cite{kacsuk2014science}.
\begin{figure}
\centering
\def\svgwidth{0.5\columnwidth}
\input{figures/service.pdf_tex}
\caption{Service integration}
\label{archi:service}
\end{figure}

\subsection{Sub-tasking}

See Figure~\ref{archi:sub-task}. The science gateway is responsible to
execute the tasks on the infrastructure, dealing with heterogeneous
batch managers and meta-schedulers. The workflow engine is a
particular task that can submit sub-tasks to the science gateway. The
workflow engine keeps track of the dependencies between the sub-tasks
but their execution is delegated to the science gateway. The science
gateway may implement mechanisms to deal with task dependencies such
as basic dependency lists as available in most batch
managers. Although it has no global vision of the workflow, it can
keep track of the sub-tasks submitted by a given task, for instance to
be able to cancel them when the task is canceled. The fact that tasks
are submitted through the science gateway does not restrict the range
of possible execution models: pilot jobs, for instance, can still be
used.

\todo{Interactions c1 and c2 are merged in c since this is done
  completely by the science gateway}

This model is implemented in CBRAIN~\cite{SHER-14} where it is used to
integrate the PSOM workflow engine and the FSL toolkit through its
\texttt{fsl\_sub} tool. In particular, the CBRAIN-PSOM integration is
described in~\cite{GLAT-16} and uses an agent computing model (a.k.a pilot
jobs).
\begin{figure}
\centering
\def\svgwidth{0.5\columnwidth}
\input{figures/sub-task.pdf_tex}
\caption{Sub-tasking}
\label{archi:sub-task}
\end{figure}

\subsection{Pool model}
\label{sec:pool}
See Figure~\ref{archi:agent}. Workflows are submitted by the science
gateway to a pool to which agents connect asynchronously to retrieve
and execute workflows (interaction \texttt{f}). Agents may be started according to various
policies, for instance to ensure load balancing. Agents may wrap
different types of workflow engines. This model was implemented in the
SHIWA pool~\cite{ROGE-13}.
\begin{figure}
\centering
\def\svgwidth{0.8\columnwidth}
\input{figures/agent.pdf_tex}
\caption{Pool model}
\label{archi:agent}
\end{figure}

\subsection{Nested workflows}

See Figure~\ref{archi:nested}. A nested workflow is an abstract
architectural pattern where an activity of a master workflow is itself
a workflow that is executed by another engine. Nested workflows can be
instantiated in the various architectures described previously. We
focus on instantiation with the service invocation model as this is
the most used architecture. The master workflow is also called
meta-workflow. The nested workflow might be described with a different
language than the one used to describe the master workflow.

Nested workflows have long been available in workflow engines, for
instance in the Taverna workbench~\cite{oinn2004taverna}. This model
was used by the SHIWA Simulation Platform to implement Coarse-Grained
workflow interoperability~\cite{terstyanszky2014enabling}, i.e. to
integrate various workflow engines in a consistent platform. Nested
workflows are also often used implicitly to wrap scripts as
black-boxes while these scripts actually correspond to complete workflows.

\begin{figure}
\centering
\def\svgwidth{0.48\columnwidth}
\input{figures/nested-1.pdf_tex}
\def\svgwidth{0.48\columnwidth}
\input{figures/nested-2.pdf_tex}
\caption{Nested workflows. Left: abstract model. Right: instantiation with service invocation.}
\label{archi:nested}
\end{figure}

\subsection{Workflow import}

See Figure~\ref{archi:import}. This is an abstract model that we
instantiate with the service invocation architecture for
consistency. Workflows are integrated in the science gateway through
format conversion from a native format to the science gateway
format. This was implemented in the SHIWA Simulation Platform through
the IWIR language that provided a common language for portability
across grid workflow
systems~\cite{plankensteiner-prodan-etal:2013}.

\begin{figure}
\centering
\def\svgwidth{0.48\columnwidth}
\input{figures/import-1.pdf_tex}
\def\svgwidth{0.48\columnwidth}
\input{figures/import-2.pdf_tex}
\caption{Workflow import. Left: abstract model. Right: instantiation with service invocation.}
\label{archi:import}
\end{figure}


\section{Evaluation}

See Table~\ref{table:evaluation}.

We focus on the integration of workflow engines in science gateways,
i.e. we assume that the science gateway is already interfaced with the
infrastructure. 

\subsection{Evaluation metrics}

We use four main criteria to evaluate the architectures: integration
effort, robustness, modularity and scalability. Criteria break down to
specific metrics for which low values indicate good performance.

\todo{Explain these metrics better, including why the related features
  are useful.}

\todo{Refer to the metric codes.}

\emph{Integration} measures the development effort required to build
the architecture, assuming that the science gateway and infrastructure
are already integrated. It is measured by counting on the
architectural diagram the number of interactions and components to
develop or modify. It breaks down to 4 metrics that quantify the
developments related to:
\begin{itemize}[itemsep=0cm]
\item Science gateway (\texttt{I$_1$}),
\item Workflow engine (\texttt{I$_2$}),
\item Infrastructure (\texttt{I$_3$}),
\item Other components (\texttt{I$_4$}).
\end{itemize}
Interactions are counted only once, in the component from which they
originate.


\emph{Robustness} relates to the complexity of the architecture and
its ability to provide relevant debugging information about the
workflow executions. It breaks down to 3 metrics:
\begin{itemize}[itemsep=0cm]
\item Components: number of unique components involved in workflow executions.
\item Interactions: number of unique interactions involved in workflow executions. 
\item Debugging: availability of debugging information about workflow
  activities (1: difficult to obtain; 0: easy to access). Fine-grained
  information about workflow activity is required to properly
  troubleshoot workflow executions.
\end{itemize}

\emph{Modularity} measures the ability to replace elements in the
architecture, or to integrate new elements. Elements include
workflow engines, workflows and infrastructure. It breaks down in 4
metrics:
\begin{itemize}[itemsep=0cm]
\item New engine type: number of interactions or components to modify
  to integrate a new workflow engine type in the
  architecture. Modification of an interaction is deemed necessary
  when the parameters involved in this interaction are
  modified. Modification of a component is required when its code
  needs to be modified or recompiled (science gateway or workflow
  service), or when a new piece of software has to be installed
  (infrastructure only).
\item New engine version: number of interactions or components to
  modify to integrate a new version of a workflow engine in the
  architecture, assuming that another version of the same engine type
  is already available. We assume that different versions of a
  workflow engine share the same interface, i.e. they can be invoked
  using the same software. When this is not the case, the different
  versions have to be considered as different engine types.
\item New infrastructure: number of interactions or components to
  modify to integrate a new type of infrastructure in the
  architecture.
\item New workflow: number of interactions required to integrate a new
  workflow in the architecture.
\item Meta-workflow: ability to describe meta-workflows from existing
  workflows (1: not available; 0: available).
\end{itemize}

\emph{Scalability} measures the ability of the architecture to support
high workloads. It breaks down into 4 metrics:
\begin{itemize}[itemsep=0cm]
\item New engine instance (0: automated; 1: manual intervention needed).
\item Elastic engines (0: easy to implement; 1: difficult to
  implement; 2: not available).
\item Distributed engines (0: possible; 1: not possible).
\item Task scheduling (0: difficult; 1: more difficult).
\end{itemize}


%"A Formal Approach to Support Interoperability in Scientific
%Meta-workflows" (reviewed for IWSG and JoGC) has a formal model to
%evaluate CGI and FGI.
%"four major approaches for workflow interoperability include a,b,c,d" (see Terstyanzky et al, "Enabli%ng scientific workflow sharing through CGI...", FGCS 2014) -> read this ref.
% http://www.oreilly.com/programming/free/files/software-architecture-patterns.pdf


\subsection{Tight integration}

\subsection{Service invocation} 

\paragraph{Integration} Integrating a workflow engine as a service
requires to develop 3 interactions and 1 component. First, a workflow
service has to be developed and interfaced with the infrastructure
through interactions \texttt{b} and \texttt{c$_2$}
(\texttt{I$_2$}=3). In addtion, the science gateway has to be extended
to call the engine interface \texttt{d} (\texttt{I$_1$}=1).

\paragraph{Robustness} Workflow execution requires 3 components: the
science gateway, the workflow service, and the infrastructure
(\texttt{R$_1$}=3). It involves the 4 interactions \texttt{b},
\texttt{$c_1$}, \texttt{$c_2$} and \texttt{d}
(\texttt{R$_2$}=4). Fine-grained debugging information is usually easy
to obtain since the workflow service provides direct access to the
engine (\texttt{R$_3$}=0).

\paragraph{Modularity} Adding a new type of workflow engine requires
to implement the corresponding workflow service, to modify interaction
\texttt{d}, and to implement interactions \texttt{b} and
\texttt{$c_2$} (\texttt{M$_1$}=4). New engine versions can be added by
updating the workflow service without modifying any interaction
(\texttt{M$_2$}=0). Adding a new type of infrastructure requires
updates in interactions \texttt{b}, \texttt{$c_1$} and \texttt{$c_2$}
(\texttt{M$_3$}=3). New workflows are added in the science gateway or
in the workflow engine through interaction \texttt{a} only
(\texttt{M$_4$}=1). Meta-workflow are not supported by default
(\texttt{M$_5$}=1).

\paragraph{Scalability} The service architecture supports multiple
engine instances through multiple workflow services. In VIP for
instance, this feature has been available from release 1.17 (April
2016). A basic load-balancing mechanism is available that sends new
workflow executions to the engine instance that has the least active
executions. To avoid ``black-hole'' syndromes created by failing
engine instances, engine instances are automatically disabled when
workflows cannot be submitted to them. Adding a new engine instance,
however, requires manual intervention to declare the new instance in
the science gateway (\texttt{S$_1$}=1). Consequently, elastic engines
are difficult to implement because they require a mechanism to update
the science gateway configuration when a new engine instance is
available (\texttt{S$_2$}=1). Distributing the execution of a single
workflow in multiple engines is usually not possible unless the
workflow engine has specific abilities (\texttt{S$_3$}=1). The
scheduling of tasks on the infrastructure is as complex as in any
other architecture since the workflow engine might implement any kind
of scheduling policy (\texttt{S$_4$}=0).

\subsection{Sub-task}

\paragraph{Integration} Integrating a workflow engine as a sub-task
only requires to implement interaction \texttt{e} (\texttt{I$_2$}=1)
and to install the workflow engine on the infrastructure
(\texttt{I$_3$}=1). A new task type is created in the science gateway
only when a new workflow has to be integrated (see M$_4$), but this is
not required to integrate the engine itself (\texttt{I$_1$}=0).

\paragraph{Robustness} Only 2 components and 3 interactions are
involved in workflow execution (\texttt{R$_1$}=2,
\texttt{R$_2$}=3). Obtaining fine-grained information about workflow
activities is not straightforward since the science gateway has no
knowledge about the workflow topology, and the workflow engine is
integrated as a task (\texttt{R$_3$}=1).

\paragraph{Modularity} Integrating a new type of workflow engine
requires to develop interaction \texttt{e} and to install the engine
on the infrastructure (\texttt{M$_1$}=2). Updating an engine version
requires updates only on the infrastructure (\texttt{M$_2$}=1). Adding
a new infrastructure requires to update interactions \texttt{b} and
\texttt{c} in the science gateway (\texttt{M$_3$}=2). New workflows are integrated by
creating a new task in the science gateway through interaction
\texttt{a} (\texttt{M$_4$}=1), and meta-workflows are not available
(\texttt{M$_5$}=1).

\paragraph{Scalability}
New engine instances are spawned and executed on the infrastructure as
any other task upon user submission (\texttt{S$_1$}=0,
\texttt{S$_2$}=0). Such scalability properties are one of the major
interests of the sub-task architecture. Distributed engines are not
supported by default (\texttt{S$_3$}=1). Task scheduling is slightly
more complex than in the other approaches due to the special role of
the task that executes the workflow engine (\texttt{S$_4$}=1). Indeed,
the reliability of this task is critical since all the sub-tasks in
the workflow depend on it and, depending on the recovery capabilities
of the workflow engine, may need to be resubmitted if the workflow
task fails. The workflow task is also longer than all its sub-tasks,
which increases its chances of failure. In addition, task parameters,
for instance estimated walltime, are more difficult to estimate for
the workflow task than for sub-tasks which may generate issues such as
selection of wrong batch queues on clusters. Finally, the
interdependencies between the workflow task and its sub-tasks may
create deadlocks when there is contention. Say for instance that only
1 computing resource is available for the science gateway and that the
workflow task is running on it and submits sub-tasks, then the
sub-tasks could only execute when the resource is available, which
will never happen because the workflow task will not complete until
the sub-tasks complete. This configuration can be generalized to an
infrastructure with $n$ resources where $n$ workflows are
submitted. In practice, however, the number of submitted workflows
usually remains lower than the number of computing resources available
on this infrastructure, which makes such deadlocks unlikely to happen.

\subsection{Pool}

\paragraph{Integration} Integrating workflow engines through the pool
model requires interaction \texttt{d} in the science gateway
(\texttt{I$_1$=1}), interactions \texttt{b} and \texttt{c$_2$} in the
workflow engine (\texttt{I$_2$=2}), the development of the workflow
pool, agent and interaction \texttt{f} between them
(\texttt{I$_4$=3}).

\paragraph{Robustness} The science gateway, workflow pool, agent and
infrastructure are involved in a workflow execution
(\texttt{R$_1$=4}), and these components are connected through 4
interactions (\texttt{R$_2$=4}). Accessing debugging information is
not likely to be an issue since the workflow pool could implement
specific functions for that (\texttt{R$_3$=0}). 

\paragraph{Modularity} Adding a new engine type requires to wrap the
engine in the agent and to update interactions \texttt{b} and
\texttt{c$_2$} (\texttt{M$_1$=3}). Updating the version of an engine
is transparent (\texttt{M$_2$=0}), and integrating a new
infrastructure requires updates in interactions \texttt{b},
\texttt{c$_1$} and \texttt{c$_2$} (\texttt{M$_3$=3}). Integrating a
new workflow is done through interaction \texttt{a} only
(\texttt{M$_4$=1}) and meta-workflows are not available by default
(\texttt{M$_5$=1}).

\paragraph{Scalability} New engine instances only require new agents,
which is easily automated (\texttt{S$_1$=0}) and by design very
suitable for elastic computing (\texttt{S$_2$=0}). For instance,
auto-scaling rules can be implemented to start new agents when the
workload in the science gateway exceeds a certain threshold \todo{ref
  needed}. Distributed engines are not available by default
(\texttt{S$_3$=1}) and task scheduling is as complex as in any other
architecture (\texttt{S$_4$=0}).


\subsection{Nested workflows}

\subsection{Workflow import}

\begin{table*}
\centering
\begin{tabular}{rcccccc}
\textbf{Metric}                      & \textbf{Tight}
                                     & \textbf{Service}
                                     & \textbf{Sub-task}
                                     & \textbf{Pool}
                                     & \textbf{Nested}
                                     & \textbf{Import} \\
\multicolumn{7}{c}{\cellcolor[HTML]{EEEEEE}\textbf{Integration}}\\
Science gateway -- \texttt{I$_1$}    & \multirow{2}{*}{3}
                                     & \cellcolor[HTML]{99FF99}1
                                     & \cellcolor[HTML]{99FF99}0  
                                     & \cellcolor[HTML]{99FF99}1
                                     & \cellcolor[HTML]{99FF99}2
                                     & \cellcolor[HTML]{99AA99}3 \\
Workflow engine -- \texttt{I$_2$}    &
                                     & \cellcolor[HTML]{99FF99}3 
                                     & \cellcolor[HTML]{99FF99}1
                                     & \cellcolor[HTML]{99AA99}2
                                     & \cellcolor[HTML]{99AA99}2
                                     & \cellcolor[HTML]{99FF99}1 \\
Infrastructure -- \texttt{I$_3$}   & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99FF99}1
                                     & \cellcolor[HTML]{99AA99}0
                                     & \cellcolor[HTML]{99AA99}0
                                     & \cellcolor[HTML]{99FF99}0 \\
Other -- \texttt{I$_4$}              & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99AA99}3
                                     & \cellcolor[HTML]{99AA99}0
                                     & \cellcolor[HTML]{99FF99}0 \\
\textbf{Total}                       & \cellcolor[HTML]{99FF99}\textbf{3}
                                     & \cellcolor[HTML]{99FF99}\textbf{4}
                                     & \cellcolor[HTML]{99FF99}\textbf{2}
                                     & \cellcolor[HTML]{99AA99}\textbf{6}
                                     & \cellcolor[HTML]{99AA99}\textbf{4}
                                     & \cellcolor[HTML]{99AA99}\textbf{4} \\

\multicolumn{7}{c}{\cellcolor[HTML]{EEEEEE}\textbf{Robustness}}\\
Components  --   \texttt{R$_1$}      & \cellcolor[HTML]{99FF99}2
                                     & \cellcolor[HTML]{99DD99}3
                                     & \cellcolor[HTML]{99FF99}2
                                     & \cellcolor[HTML]{99AA99}4  
                                     & \cellcolor[HTML]{99AA99}4 
                                     & \cellcolor[HTML]{99AA99}4 \\
Interactions -- \texttt{R$_2$}       & \cellcolor[HTML]{99FF99}3    
                                     & \cellcolor[HTML]{99DD99}4
                                     & \cellcolor[HTML]{99DD99}3      
                                     & \cellcolor[HTML]{99AA99}4  
                                     & \cellcolor[HTML]{99AA99}4      
                                     & \cellcolor[HTML]{99AA99}4 \\
Debugging --    \texttt{R$_3$}       & \cellcolor[HTML]{99AA99}0          
                                     & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99AA99}1
                                     & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99AA99}1
                                     & \cellcolor[HTML]{99FF99}0 \\
\textbf{Total}                       & \cellcolor[HTML]{99FF99}\textbf{4}
                                     & \cellcolor[HTML]{99CC99}\textbf{7}
                                     & \cellcolor[HTML]{99CC99}\textbf{6}
                                     & \cellcolor[HTML]{99BB99}\textbf{8}
                                     & \cellcolor[HTML]{99AA99}\textbf{9}
                                     & \cellcolor[HTML]{99BB99}\textbf{8} \\
\multicolumn{7}{c}{\cellcolor[HTML]{EEEEEE}\textbf{Modularity}}\\
New engine type -- \texttt{M$_1$}    & \cellcolor[HTML]{99AA99}3
                                     & \cellcolor[HTML]{99DD99}4
                                     & \cellcolor[HTML]{99FF99}2
                                     & \cellcolor[HTML]{99DD99}3
                                     & \cellcolor[HTML]{99DD99}2
                                     & \cellcolor[HTML]{99AA99}3 \\
New engine version -- \texttt{M$_2$} & \cellcolor[HTML]{99AA99}1
                                     & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99FF99}1
                                     & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99FF99}0 \\
New infrastructure -- \texttt{M$_3$} & \cellcolor[HTML]{99FF99}2
                                     & \cellcolor[HTML]{99FF99}3
                                     & \cellcolor[HTML]{99FF99}2
                                     & \cellcolor[HTML]{99FF99}3
                                     & \cellcolor[HTML]{99FF99}2
                                     & \cellcolor[HTML]{99FF99}2 \\
New workflow -- \texttt{M$_4$}       & \cellcolor[HTML]{99FF99}1
                                     & \cellcolor[HTML]{99FF99}1
                                     & \cellcolor[HTML]{99FF99}1
                                     & \cellcolor[HTML]{99FF99}1
                                     & \cellcolor[HTML]{99FF99}1
                                     & \cellcolor[HTML]{99AA99}2 \\
Meta-workflow  -- \texttt{M$_5$}     & \cellcolor[HTML]{99AA99}1
                                     & \cellcolor[HTML]{99AA99}1  
                                     & \cellcolor[HTML]{99AA99}1
                                     & \cellcolor[HTML]{99AA99}1
                                     & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99AA99}1 \\
\textbf{Total}                       & \cellcolor[HTML]{99AA99}\textbf{8}
                                     & \cellcolor[HTML]{99EE99}\textbf{9}
                                     & \cellcolor[HTML]{99FF99}\textbf{7}
                                     & \cellcolor[HTML]{99EE99}\textbf{8}
                                     & \cellcolor[HTML]{99FF99}\textbf{5}
                                     & \cellcolor[HTML]{99AA99}\textbf{8} \\
\multicolumn{7}{c}{\cellcolor[HTML]{EEEEEE}\textbf{Scalability}}\\
New engine instance -- \texttt{S$_1$}& \cellcolor[HTML]{99AA99}1
                                     & \cellcolor[HTML]{99AA99}1
                                     & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99AA99}1
                                     & \cellcolor[HTML]{99AA99}1 \\
Elastic engines -- \texttt{S$_2$}    & \cellcolor[HTML]{99AA99}2
                                     & \cellcolor[HTML]{99DD99}1
                                     & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99DD99}1
                                     & \cellcolor[HTML]{99DD99}1 \\
Distributed engines -- \texttt{S$_3$}& \cellcolor[HTML]{99AA99}1
                                     & \cellcolor[HTML]{99AA99}1
                                     & \cellcolor[HTML]{99AA99}1
                                     & \cellcolor[HTML]{99AA99}1
                                     & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99AA99}1 \\
Task scheduling -- \texttt{S$_4$}    & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99AA99}1
                                     & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99FF99}0
                                     & \cellcolor[HTML]{99FF99}0 \\
\textbf{Total}                       & \cellcolor[HTML]{99AA99}\textbf{4}
                                     & \cellcolor[HTML]{99BB99}\textbf{3}
                                     & \cellcolor[HTML]{99DD99}\textbf{2}
                                     & \cellcolor[HTML]{99FF99}\textbf{1}
                                     & \cellcolor[HTML]{99DD99}\textbf{2}
                                     & \cellcolor[HTML]{99BB99}\textbf{3} \\
\multicolumn{7}{c}{\cellcolor[HTML]{EEEEEE}\textbf{Grand total}}\\
                                     & \cellcolor[HTML]{99CC99}\textbf{19}
                                     & \cellcolor[HTML]{99BB99}\textbf{23}
                                     & \cellcolor[HTML]{99FF99}\textbf{17}
                                     & \cellcolor[HTML]{99CC99}\textbf{23}
                                     & \cellcolor[HTML]{99DD99}\textbf{20}
                                     & \cellcolor[HTML]{99AA99}\textbf{23}
\end{tabular}
\caption{Architecture evaluation. Lower values (brighter colors) indicate better performance. \todo{update colors and find a more relevant way to compute a grand total without favoring criteria that have more metrics than the others (e.g. normalize each criterion between 0 and 1).}}
\label{table:evaluation}
\end{table*}



\section{Discussion}

Comparison between architectures, per criterion (robustness, etc).

This ignores pre-existing work (e.g. a workflow engine is already available as a service). Migration across architectures too.

These architectures can be combined (give examples). 

\section{Conclusion}

\section{Acknowledgments}

FLI-IAM, Labex PRIMES, Ludmer Centre

\section*{References}

\bibliographystyle{elsarticle-num} 
\bibliography{biblio}

\end{document}
\endinput
